using System;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Moriarty.Msrc
{
    public class CVE_2021_44228 : IVulnerabilityCheck
    {
        private const string Id = "CVE-2021-44228";
        private static readonly string[] Exploits = new[]
        {
            "https://github.com/CERTCC/CVE-2021-44228_scanner"
        };

        public Vulnerability GetVulnerability()
        {
            return new Vulnerability(Id, Exploits);
        }

        public void Check(VulnerabilityCollection vulnerabilities, int buildNumber, List<int> installedKBs)
        {
            // Define the most likely folders to contain vulnerable files
            var likelyFolders = new List<string>
            {
                @"C:\Program Files\",
                @"C:\Program Files (x86)\",
                // Add any specific directories known to contain Java applications or libraries
                // Examples could include directories for commonly used Java servers or applications
            };
            DebugUtility.DebugPrint("Starting targeted scan...");

            foreach (var folder in likelyFolders)
            {
                if (Directory.Exists(folder))
                {
                    DebugUtility.DebugPrint($"Scanning directory: {folder}");
                    ScanDirectory(folder, vulnerabilities);
                }
                else
                {
                    DebugUtility.DebugPrint($"Directory does not exist: {folder}");
                }
            }
        }

        private static void ScanDirectory(string directoryPath, VulnerabilityCollection vulnerabilities, int currentDepth = 0, int maxDepth = 3)
        {
            if (currentDepth > maxDepth)
            {
                return;
            }

            DebugUtility.DebugPrint($"Scanning directory: {directoryPath} at depth {currentDepth}");

            // Process files in the current directory
            try
            {
                var fileExtensions = new[] { ".jar", ".war", ".ear", ".zip" };
                var files = Directory.EnumerateFiles(directoryPath, "*.*")
                                     .Where(file => fileExtensions.Any(x => file.EndsWith(x, StringComparison.OrdinalIgnoreCase)));

                Parallel.ForEach(files, (file) =>
                {
                    DebugUtility.DebugPrint($"Processing file: {file}");
                    ProcessFile(file, vulnerabilities);
                });

                // Recursively process subdirectories, limiting the depth
                var directories = Directory.EnumerateDirectories(directoryPath);
                foreach (var dir in directories)
                {
                    ScanDirectory(dir, vulnerabilities, currentDepth + 1, maxDepth);
                }
            }
            catch (UnauthorizedAccessException ex)
            {
                DebugUtility.DebugPrint($"Access denied to directory: {directoryPath}. Exception: {ex.Message}");
                // Optionally, log the exception or handle it as necessary.
            }
            catch (Exception ex)
            {
                DebugUtility.DebugPrint($"Error processing directory {directoryPath}: {ex.Message}");
                // Handle other exceptions or log them as necessary.
            }
        }


        private static void ProcessFile(string filePath, VulnerabilityCollection vulnerabilities)
        {
            DebugUtility.DebugPrint($"Opening archive: {filePath}");
            try
            {
                using (ZipArchive archive = ZipFile.OpenRead(filePath))
                {
                    foreach (ZipArchiveEntry entry in archive.Entries)
                    {
                        if (entry.FullName.EndsWith("JndiLookup.class", StringComparison.OrdinalIgnoreCase))
                        {
                            CheckForVulnerability(entry, filePath, vulnerabilities);
                        }
                        else if (IsArchive(entry.FullName))
                        {
                            string tempPath = Path.GetTempFileName();
                            DebugUtility.DebugPrint($"Extracting nested archive to temporary file: {tempPath}");
                            entry.ExtractToFile(tempPath, true);
                            ProcessFile(tempPath, vulnerabilities);
                            File.Delete(tempPath);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                DebugUtility.DebugPrint($"Error processing file {filePath}: {ex.Message}");
            }
            DebugUtility.DebugPrint($"Finished processing archive: {filePath}");
        }

        private static bool IsArchive(string fileName)
        {
            var archiveExtensions = new[] { ".jar", ".war", ".ear", ".zip" };
            return archiveExtensions.Any(ext => fileName.EndsWith(ext, StringComparison.OrdinalIgnoreCase));
        }

        private static void CheckForVulnerability(ZipArchiveEntry entry, string originalFilePath, VulnerabilityCollection vulnerabilities)
        {
            string tempPath = Path.GetTempFileName();
            DebugUtility.DebugPrint($"Extracting entry {entry.FullName} to temporary file: {tempPath}");
            entry.ExtractToFile(tempPath, true);
            string fileContent = File.ReadAllText(tempPath);

            if (Regex.IsMatch(fileContent, "LogEvent") && !Regex.IsMatch(fileContent, "JNDI is not supported"))
            {
                DebugUtility.DebugPrint($"Vulnerability found in {originalFilePath} -> {entry.FullName}");
                vulnerabilities.SetAsVulnerable(Id);
            }
            else
            {
                DebugUtility.DebugPrint($"No vulnerability found in {originalFilePath} -> {entry.FullName}");
            }

            File.Delete(tempPath);
        }
    }
}